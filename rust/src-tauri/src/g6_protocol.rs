/// USB Protocol implementation for SoundBlaster X G6
/// Based on reverse engineering from soundblaster-x-g6-cli project

use crate::g6_spec::{EffectState, OutputDevice, SmartVolumePreset};

// Protocol constants
const PREFIX: u8 = 0x5a;
const REQUEST_DATA: u16 = 0x1207;
const REQUEST_COMMIT: u16 = 0x1103;
const INTERMEDIATE: u16 = 0x0196;
const PAYLOAD_SIZE: usize = 64;

// Read command codes (discovered from USB capture)
const CMD_STATUS_QUERY: u8 = 0x05;
const CMD_QUERY_10: u8 = 0x10;
const CMD_QUERY_15: u8 = 0x15;
const CMD_QUERY_20: u8 = 0x20;
const CMD_QUERY_30: u8 = 0x30;
const CMD_QUERY_39: u8 = 0x39;
const CMD_QUERY_3A: u8 = 0x3a;

// Feature hex codes (for toggles)
const FEATURE_SURROUND: u8 = 0x00;
const FEATURE_CRYSTALIZER: u8 = 0x07;
const FEATURE_BASS: u8 = 0x18;
const FEATURE_SMART_VOLUME: u8 = 0x04;
const FEATURE_DIALOG_PLUS: u8 = 0x02;

// Feature hex codes (for sliders = feature + 1)
const FEATURE_SURROUND_SLIDER: u8 = 0x01;
const FEATURE_CRYSTALIZER_SLIDER: u8 = 0x08;
const FEATURE_BASS_SLIDER: u8 = 0x19;
const FEATURE_SMART_VOLUME_SLIDER: u8 = 0x05;
const FEATURE_SMART_VOLUME_SPECIAL: u8 = 0x06;
const FEATURE_DIALOG_PLUS_SLIDER: u8 = 0x03;

// Toggle values
const VALUE_ENABLED: u32 = 0x3f800000; // 1.0f as little-endian u32 (bytes: 00 00 80 3f)
const VALUE_DISABLED: u32 = 0x00000000;

// Smart Volume special values  
const VALUE_SMART_VOLUME_NIGHT: u32 = 0x40000000; // 0.5f (bytes: 00 00 00 40)
const VALUE_SMART_VOLUME_LOUD: u32 = 0x3f800000;  // 1.0f (bytes: 00 00 80 3f)

/// Build a 64-byte USB HID command
fn build_command(request_type: u16, feature: u8, value: u32) -> Vec<u8> {
    let mut command = Vec::with_capacity(PAYLOAD_SIZE);
    
    // Prefix (1 byte)
    command.push(PREFIX);
    
    // Request type (2 bytes, big-endian)
    command.extend_from_slice(&request_type.to_be_bytes());
    
    // Intermediate (2 bytes, big-endian)
    command.extend_from_slice(&INTERMEDIATE.to_be_bytes());
    
    // Feature (1 byte)
    command.push(feature);
    
    // Value (4 bytes, little-endian as per USB spec)
    command.extend_from_slice(&value.to_le_bytes());
    
    // Padding to 64 bytes
    command.resize(PAYLOAD_SIZE, 0x00);
    
    command
}

/// Build command pair (DATA + COMMIT) for a toggle operation
pub fn build_toggle_commands(feature: u8, enabled: bool) -> Vec<Vec<u8>> {
    let value = if enabled { VALUE_ENABLED } else { VALUE_DISABLED };
    
    vec![
        build_command(REQUEST_DATA, feature, value),
        build_command(REQUEST_COMMIT, feature, 0),
    ]
}

/// Build command pair (DATA + COMMIT) for a slider operation
pub fn build_slider_commands(feature: u8, value: u8) -> Vec<Vec<u8>> {
    // Convert 0-100 value to the G6's expected format
    let hex_value = value_to_hex(value);
    
    vec![
        build_command(REQUEST_DATA, feature, hex_value),
        build_command(REQUEST_COMMIT, feature, 0),
    ]
}

/// Convert a 0-100 value to the G6's hex representation
/// The G6 expects IEEE 754 floating point values from 0.0 to 1.0
fn value_to_hex(value: u8) -> u32 {
    // Convert 0-100 to 0.0-1.0 range
    let float_val = (value as f32) / 100.0;
    
    // Convert to IEEE 754 little-endian bytes and then to u32
    let bytes = float_val.to_le_bytes();
    u32::from_le_bytes(bytes)
}

/// Build commands for surround effect
pub fn build_surround_toggle(enabled: bool) -> Vec<Vec<u8>> {
    build_toggle_commands(FEATURE_SURROUND, enabled)
}

pub fn build_surround_slider(value: u8) -> Vec<Vec<u8>> {
    build_slider_commands(FEATURE_SURROUND_SLIDER, value)
}

/// Build commands for crystalizer effect
pub fn build_crystalizer_toggle(enabled: bool) -> Vec<Vec<u8>> {
    build_toggle_commands(FEATURE_CRYSTALIZER, enabled)
}

pub fn build_crystalizer_slider(value: u8) -> Vec<Vec<u8>> {
    build_slider_commands(FEATURE_CRYSTALIZER_SLIDER, value)
}

/// Build commands for bass effect
pub fn build_bass_toggle(enabled: bool) -> Vec<Vec<u8>> {
    build_toggle_commands(FEATURE_BASS, enabled)
}

pub fn build_bass_slider(value: u8) -> Vec<Vec<u8>> {
    build_slider_commands(FEATURE_BASS_SLIDER, value)
}

/// Build commands for smart volume effect
pub fn build_smart_volume_toggle(enabled: bool) -> Vec<Vec<u8>> {
    build_toggle_commands(FEATURE_SMART_VOLUME, enabled)
}

pub fn build_smart_volume_slider(value: u8) -> Vec<Vec<u8>> {
    build_slider_commands(FEATURE_SMART_VOLUME_SLIDER, value)
}

pub fn build_smart_volume_special(preset: SmartVolumePreset) -> Vec<Vec<u8>> {
    let value = match preset {
        SmartVolumePreset::Night => VALUE_SMART_VOLUME_NIGHT,
        SmartVolumePreset::Loud => VALUE_SMART_VOLUME_LOUD,
    };
    
    vec![
        build_command(REQUEST_DATA, FEATURE_SMART_VOLUME_SPECIAL, value),
        build_command(REQUEST_COMMIT, FEATURE_SMART_VOLUME_SPECIAL, 0),
    ]
}

/// Build commands for dialog plus effect  
pub fn build_dialog_plus_toggle(enabled: bool) -> Vec<Vec<u8>> {
    build_toggle_commands(FEATURE_DIALOG_PLUS, enabled)
}

pub fn build_dialog_plus_slider(value: u8) -> Vec<Vec<u8>> {
    build_slider_commands(FEATURE_DIALOG_PLUS_SLIDER, value)
}

/// Parse hex string to bytes
fn hex_to_bytes(hex: &str) -> Vec<u8> {
    (0..hex.len())
        .step_by(2)
        .map(|i| u8::from_str_radix(&hex[i..i + 2], 16).unwrap())
        .collect()
}

/// Build commands for switching to headphones
pub fn build_output_headphones() -> Vec<Vec<u8>> {
    vec![
        hex_to_bytes("5a2c0500040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a2c0101000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a120701960a00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a110301960a00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a120701960b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a110301960b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a120701960c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a110301960c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a120701960d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a110301960d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a120701960e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a110301960e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a120701960f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a110301960f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a120701961000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a110301961000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a120701961100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a110301961100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a120701961200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a110301961200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a120701961300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a110301961300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a120701961400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a110301961400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a120701960900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a110301960900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a120701960600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a110301960600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a120701960900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a110301960900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
    ]
}

/// Build commands for switching to speakers
pub fn build_output_speakers() -> Vec<Vec<u8>> {
    vec![
        hex_to_bytes("5a2c0500020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a2c0101000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a120701960a00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a110301960a00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a120701960b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a110301960b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a120701960c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a110301960c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a120701960d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a110301960d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a120701960e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a110301960e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a120701960f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a110301960f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a120701961000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a110301961000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a120701961100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a110301961100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a120701961200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a110301961200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a120701961300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a110301961300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a120701961400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a110301961400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a120701960900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a110301960900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a120701960900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        hex_to_bytes("5a110301960900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
    ]
}

/// Build commands for toggling output
pub fn build_output_toggle(current: OutputDevice) -> Vec<Vec<u8>> {
    match current {
        OutputDevice::Headphones => build_output_speakers(),
        OutputDevice::Speakers => build_output_headphones(),
    }
}

// ============================================================================
// READ COMMANDS - Discovered from USB capture analysis
// ============================================================================

/// Build a simple read command (just prefix + command byte + padding)
fn build_read_command(cmd: u8) -> Vec<u8> {
    let mut command = Vec::with_capacity(PAYLOAD_SIZE);
    command.push(PREFIX);
    command.push(cmd);
    command.resize(PAYLOAD_SIZE, 0x00);
    command
}

/// Build a read command with parameters
fn build_read_command_with_params(cmd: u8, param1: u8, param2: u8) -> Vec<u8> {
    let mut command = Vec::with_capacity(PAYLOAD_SIZE);
    command.push(PREFIX);
    command.push(cmd);
    command.push(param1);
    command.push(param2);
    command.resize(PAYLOAD_SIZE, 0x00);
    command
}

/// Build command 0x05 - General status query
/// This appears to be the primary device status read command
pub fn build_status_query() -> Vec<u8> {
    build_read_command(CMD_STATUS_QUERY)
}

/// Build command 0x10
pub fn build_query_10() -> Vec<u8> {
    build_read_command(CMD_QUERY_10)
}

/// Build command 0x15 with parameter
pub fn build_query_15() -> Vec<u8> {
    build_read_command_with_params(CMD_QUERY_15, 0x01, 0x00)
}

/// Build command 0x20
pub fn build_query_20() -> Vec<u8> {
    build_read_command(CMD_QUERY_20)
}

/// Build command 0x30
pub fn build_query_30() -> Vec<u8> {
    build_read_command(CMD_QUERY_30)
}

/// Build command 0x39 with parameters
pub fn build_query_39() -> Vec<u8> {
    build_read_command_with_params(CMD_QUERY_39, 0x01, 0x04)
}

/// Build command 0x3a variant 1 (param: 02 09)
pub fn build_query_3a_variant1() -> Vec<u8> {
    build_read_command_with_params(CMD_QUERY_3A, 0x02, 0x09)
}

/// Build command 0x3a variant 2 (param: 01 07)
pub fn build_query_3a_variant2() -> Vec<u8> {
    build_read_command_with_params(CMD_QUERY_3A, 0x01, 0x07)
}

/// Build full device state read sequence
/// This sends all the read commands in the order the Creative software uses
pub fn build_full_device_read_sequence() -> Vec<Vec<u8>> {
    vec![
        build_status_query(),        // 0x05
        build_query_10(),             // 0x10
        build_query_20(),             // 0x20
        build_query_30(),             // 0x30
        build_query_15(),             // 0x15 with param
        build_query_3a_variant1(),    // 0x3a 02 09
        build_status_query(),         // 0x05 again
        build_query_39(),             // 0x39 01 04
        build_query_3a_variant2(),    // 0x3a 01 07
    ]
}
